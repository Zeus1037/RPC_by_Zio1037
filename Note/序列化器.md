## 主流序列化方式对比

| **序列化器**               | **优点**                                                     | **缺点**                                                     |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **原生 Java Serializable** | 1. 简单易用，便于Java应用中的对象持久化。<br />2. 兼容性好，与Java语言及框架无缝集成，操作流畅。 | 1. 性能差。  <br />2. 调试困难。 <br />3. 无版本控制，类结构调整易引发反序列化问题或数据不一致，而 Protobuf 具有良好的版本兼容性。 |
| **JSON**                   | 1. 易读性好，可读性强，便于人类理解和调试。 <br />2. 跨语言支持广泛，几乎所有编程语言都有 JSON 的解析和生成库。 | 1. 序列化后的数据量较大，因为 JSON 以文本格式存储，需要额外的字符来表示键、值和结构。  <br />2. JSON 在处理复杂数据结构和循环引用时能力较弱，可能导致性能下降或序列化失败。 |
| **Hessian**                | 1. 二进制序列化数据量小，传输效率高。 <br />2. 支持跨语言，适合分布式系统服务调用。 | 1. 性能较JSON略低，因为需要将对象转换为二进制格式。<br />2. 对象必须实现Serializable接口，限制了可序列化的对象范围。 |
| **Kryo**                   | 1. 高性能，序列化和反序列化速度快。 <br />2. 支持循环引用和自定义序列化器，适用于复杂的对象结构。 <br />3. 无需实现Serializable接口，可以序列化任意对象。 | 1. 不跨语言，只适用于Java。 <br />2. 对象的序列化格式不够友好，不易读懂和调试。 |
| **Protobuf**               | 1. 高效的二进制序列化，序列化后的数据量极小。 <br />2. 跨语言支持，并且提供了多种语言的实现库。 3. 支持版本化和向前/向后兼容性。 | 1. 配置相对复杂，需要先定义数据结构的消息格式。 <br />2. 对象的序列化格式不易读懂，不便于调试。 |

